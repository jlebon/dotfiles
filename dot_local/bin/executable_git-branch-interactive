#!/bin/bash
set -euo pipefail

## Navigation:
## 
## Select up/down                   Ctrl-K, Ctrl-J
## Scroll commits up/down           Ctrl-U, Ctrl-D
## Scroll preview up/down           Alt-U, Alt-D
## Scroll preview up/down one line  Alt-Y, Alt-E
## 
## Git operations:
## 
## Checkout branch  Enter
## Delete branch    Ctrl-X
## Force delete     Ctrl-F
## Rename branch    Ctrl-R
## Browse branch    Ctrl-Space
## 
## Misc:
## 
## Show this help                         F1
## Change preview location                F2
## Toggle preview                         Ctrl-/
## Toggle merged-only filter              Ctrl-O
## Copy branch names to tmux and stdout   Ctrl-G

if [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" != "true" ]; then
    echo "error: not inside a git repo" >&2
    exit 1
fi

if [ "${1:-}" = command ]; then
    default_local=$(git default -l)
    default_ref=$(git default -r)
    default_sha=$(git rev-parse "${default_ref}")
    
    # Load cache (only entries matching current default_sha)
    cache_file="$(git rev-parse --git-dir)/branch-interactive-cache"
    declare -A cache
    if [ -f "$cache_file" ]; then
        while IFS=$'\t' read -r b_sha d_sha marker; do
            [ "$d_sha" = "$default_sha" ] && cache["$b_sha"]="$marker"
        done < "$cache_file"
    fi
    
    while IFS= read -r branch; do
        [ "$branch" = "$default_local" ] && continue
        
        branch_sha=$(git rev-parse "$branch")
        
        # Check cache first
        if [ -n "${cache[$branch_sha]+x}" ]; then
            marker="${cache[$branch_sha]}"
        else
            # Compute marker
            marker=""
            if merge_base=$(git merge-base "${default_ref}" "$branch" 2>/dev/null); then
                # Check if there are any commits on the branch
                if [ "$(git rev-list --count "${merge_base}..${branch}")" -gt 0 ]; then
                    # Check git cherry first (exact patch match)
                    # If all lines start with '-', all commits have been applied upstream
                    if ! git cherry "${default_ref}" "$branch" 2>/dev/null | grep -qv '^-'; then
                        marker="üçí"
                    else
                        # Fall back to title matching (for squash merges)
                        all_merged=true
                        while IFS= read -r title; do
                            if ! git log --format='%s' "${merge_base}..${default_ref}" | grep -qxF "$title"; then
                                all_merged=false
                                break
                            fi
                        done < <(git log --format='%s' "${merge_base}..${branch}")
                        [ "$all_merged" = true ] && marker="üîÄ"
                    fi
                else
                    # Branch has no unique commits - truly merged
                    marker="‚úÖ"
                fi
            fi
            cache["$branch_sha"]="$marker"
        fi
        
        # Always use tab delimiter for consistent fzf field parsing
        printf '%s\t%s\n' "$branch" "$marker"
    done < <(git branch -v --sort=-committerdate --format "%(refname:lstrip=2)")
    
    # Write cache atomically
    {
        for b_sha in "${!cache[@]}"; do
            printf '%s\t%s\t%s\n' "$b_sha" "$default_sha" "${cache[$b_sha]}"
        done
    } > "${cache_file}.tmp" && mv "${cache_file}.tmp" "$cache_file"
    
    exit 0
elif [ "${1:-}" = command-merged ]; then
    # Show only merged branches (those with markers)
    "$0" command | grep $'\t'
    exit 0
elif [ "${1:-}" = preview ]; then
    default_ref=$(git default -r)
    if merge_base=$(git merge-base "${default_ref}" "$2" 2>/dev/null); then
        git lg --color=always "$2" "^${merge_base}"
        echo
        printf '%.s‚îÄ' $(seq 1 "${FZF_PREVIEW_COLUMNS:-$COLUMNS}")
        git diff --color=always "${merge_base}" "$2"
    else
        echo "No common ancestry with ${default_ref}"
        echo
        git lg --color=always "$2"
        echo
        printf '%.s‚îÄ' $(seq 1 "${FZF_PREVIEW_COLUMNS:-$COLUMNS}")
        git diff --color=always "${default_ref}" "$2"
    fi
    exit 0
fi

export FZF_DEFAULT_COMMAND="$0 command"
# export FZF_DEFAULT_COMMAND="git branch --color=always --format '%(authordate:short)%(color:bold)  %(refname:lstrip=2)' --sort=authordate $* | tac"

tmux=true
if [ -n "${TMUX:-}" ]; then
    tmux=tmux
fi

fzf --track --ansi --tiebreak=index -m -d $'\t' \
    --highlight-line --cycle \
    --border=rounded --border-label=' Git Branches (F1: help) ' \
    --preview-label=' Commits & Diff ' \
    --preview "$0 preview {1}" \
    --bind "f1:execute(grep '^## ' '$0' | cut -f2- -d' ' | less)" \
    --bind 'f2:change-preview-window(down|right|hidden)' \
    --bind 'focus:transform-preview-label:echo " {1} "' \
    --bind 'ctrl-d:half-page-down,ctrl-u:half-page-up' \
    --bind 'alt-e:preview-down,alt-y:preview-up,alt-d:preview-half-page-down,alt-u:preview-half-page-up' \
    --bind 'enter:become:git checkout {1}' \
    --bind 'ctrl-space:execute:git lgi {1}' \
    --bind "ctrl-o:transform:[[ \$FZF_BORDER_LABEL == *Merged* ]] && echo 'reload($0 command)+change-border-label( Git Branches (F1: help) )' || echo 'reload($0 command-merged)+change-border-label( Merged Branches (F1: help) )'" \
    --bind "ctrl-x:execute-silent(git branch -d {+1})+transform:[[ \$FZF_BORDER_LABEL == *Merged* ]] && echo 'reload($0 command-merged)+pos({n})' || echo 'reload($0 command)+pos({n})'" \
    --bind "ctrl-f:execute-silent(git branch -D {+1})+transform:[[ \$FZF_BORDER_LABEL == *Merged* ]] && echo 'reload($0 command-merged)+pos({n})' || echo 'reload($0 command)+pos({n})'" \
    --bind 'ctrl-r:execute:read -p "New name for {1}: " name && git branch -m {1} "$name"' \
    --bind "ctrl-r:+transform:[[ \$FZF_BORDER_LABEL == *Merged* ]] && echo 'reload($0 command-merged)' || echo 'reload($0 command)'" \
    --bind 'ctrl-/:toggle-preview' \
    --bind "ctrl-g:become:$tmux set-buffer '{+1}' && echo {+1}"
