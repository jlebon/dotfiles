#!/bin/bash
set -euo pipefail
shopt -s inherit_errexit

# Detect invocation mode based on how we were called
case "$(basename "$0")" in
    xoc) mode=opencode ;;
    *)   mode=claude ;;
esac

# Run claude/opencode in an unprivileged container using the same container
# image in which we're running. The primary use case is a pet container image
# you've customized with various dev tools, and you want Claude/OpenCode to
# be able to use those tools as well in --dangerously-skip-permissions mode.
# Note this runs `podman`; in my case, `podman` is actually ~/.local/bin/podman
# and just proxies to the real host podman via `host-spawn`. That wrapper is
# available in my dotfiles repo as well, but one can probably just change the
# podman call at the bottom to `flatpak-spawn --host`

if [ ! -e "/run/.containerenv" ]; then
    echo "ERROR: Must be run from pet container" >&2
    exit 1
fi

# Parse our own arguments
add_dirs=()
add_repos=()
extra_volumes=()
tool_args=()
git_mount_mode=ro
run_bash=false
custom_image=""
mount_gh=false
mount_glab=false
mount_oci_auth=false
mount_imgs=false
clean_volumes=false
force_update=false
usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS] [-- ARGS...]

Run claude/opencode in an unprivileged container.

Options:
  -h            Show this help message
  --git-rw      Mount .git directory read-write (default: read-only)
  --bash        Run bash instead of claude/opencode
  --image IMG   Use a custom container image
  --gh          Mount GitHub credentials and set GITHUB_TOKEN
  --glab        Mount GitLab CLI config
  --oci-auth    Mount Docker config (~/.docker/config.json)
  --imgs        Mount /srv/imgs read-write
  --add-dir DIR Add a directory to the container (passes --add-dir to claude)
  --add-repo R  Add a repo (comma-separated) from ~/Code
  -v VOLUME     Add an extra volume mount
  --clean       Remove existing named volumes before starting
  --update      Force an opencode update (opencode mode only)
  --            Stop parsing options; remaining args passed to tool
EOF
}

while [ $# -gt 0 ]; do
    case "$1" in
        -h)
            usage
            exit 0
            ;;
        --)
            shift
            tool_args+=("$@")
            break
            ;;
        --git-rw)
            git_mount_mode=rw
            shift
            ;;
        --bash)
            run_bash=true
            shift
            ;;
        --image)
            if [ -z "${2:-}" ]; then
                echo "ERROR: --image requires an image argument" >&2
                exit 1
            fi
            custom_image="$2"
            shift 2
            ;;
        --gh)
            mount_gh=true
            shift
            ;;
        --glab)
            mount_glab=true
            shift
            ;;
        --oci-auth)
            mount_oci_auth=true
            shift
            ;;
        --imgs)
            mount_imgs=true
            shift
            ;;
        --clean)
            clean_volumes=true
            shift
            ;;
        --update)
            force_update=true
            shift
            ;;
        --add-dir)
            if [ -z "${2:-}" ]; then
                echo "ERROR: --add-dir requires a directory argument" >&2
                exit 1
            fi
            add_dirs+=("$(realpath "$2")")
            shift 2
            ;;
        --add-repo)
            if [ -z "${2:-}" ]; then
                echo "ERROR: --add-repo requires a repo name argument" >&2
                exit 1
            fi
            IFS=',' read -ra repos <<< "$2"
            add_repos+=("${repos[@]}")
            shift 2
            ;;
        -v)
            if [ -z "${2:-}" ]; then
                echo "ERROR: -v requires a volume argument" >&2
                exit 1
            fi
            extra_volumes+=("$2")
            shift 2
            ;;
        *)
            tool_args+=("$1")
            shift
            ;;
    esac
done

if [ ! -e .git ] && [ -z "${SAFE_PWD:-}" ]; then
    echo "ERROR: not in a git repo" >&2
    exit 1
fi

# Check if there's a newer version of claude-code available
if [ "${mode}" = "claude" ]; then
    claude_manifest=~/Code/nodejs/lib/node_modules/\@anthropic-ai/claude-code/package.json
    current_version=$(jq -r '.version' "${claude_manifest}")
    latest_version=$(curl -s https://registry.npmjs.org/@anthropic-ai/claude-code/latest | jq -r '.version')
    if [ -n "${latest_version}" ] && [ "${current_version}" != "${latest_version}" ]; then
        echo "Updating @anthropic-ai/claude-code from ${current_version} to ${latest_version}..."
        npm update --prefix ~/Code/nodejs -g @anthropic-ai/claude-code
    fi
fi

cd "$(realpath "${PWD}")"

# Mount target symlink if it exists in a directory. This handles the case
# where `target/` is a symlink to an external cache directory (see `mkcachedir`).
mount_target_symlink() {
    local dir="$1"
    if [ -L "${dir}/target" ]; then
        local target_real
        target_real=$(realpath "${dir}/target")
        podman_args+=(-v "${target_real}:${target_real}")
    fi
}

# Generate volume prefix from working directory for named volumes
vol_hash=$(echo "$PWD" | md5sum | cut -c1-8)
vol_slug=$(basename "$PWD" | tr -cs 'a-zA-Z0-9' '-' | sed 's/-$//')
vol_prefix="xclaude-${vol_hash}-${vol_slug}"

# Clean up existing volumes if requested
if [ "${clean_volumes}" = "true" ]; then
    podman volume rm -f "${vol_prefix}-containers" "${vol_prefix}-var-tmp" "${vol_prefix}-tmp" 2>/dev/null || true
fi

if [ -n "${custom_image}" ]; then
    imageid="${custom_image}"
else
    imageid=$(source /run/.containerenv; echo "${imageid}")
fi

podman_args=(
    run --rm -ti
    --detach-keys ""
    --privileged
    -v "${vol_prefix}-containers:/var/lib/containers"
    -v "${vol_prefix}-var-tmp:/var/tmp"
    -v "${vol_prefix}-tmp:/tmp"
    --label "${mode}=1"
    --env PATH
    --env HOME="${HOME}"
    --tmpfs "${HOME}"
    --tz local
    -v "${HOME}/.cache"
    -v "${HOME}/.cargo:${HOME}/.cargo"
    -v "${HOME}/.rustup:${HOME}/.rustup:ro"
    -v "${HOME}"/Code/nodejs:"${HOME}"/Code/nodejs:O
    -v "${HOME}"/.config/gcloud:"${HOME}"/.config/gcloud:ro
    -v "${PWD}":"${PWD}"
    -w "${PWD}"
)

# Mode-specific mounts
if [ "${mode}" = "claude" ]; then
    podman_args+=(
        -v "${HOME}"/.claude.json:"${HOME}"/.claude.json
        -v "${HOME}"/.claude:"${HOME}"/.claude
    )
else
    podman_args+=(
        -v "${HOME}"/.opencode:"${HOME}"/.opencode
        -v "${HOME}"/.config/opencode:"${HOME}"/.config/opencode
        -v "${HOME}"/.local/share/opencode:"${HOME}"/.local/share/opencode
        -v "${HOME}"/.local/state/opencode:"${HOME}"/.local/state/opencode
        -v "${HOME}"/.cache/opencode:"${HOME}"/.cache/opencode
    )
    # --publish 192.168.2.1:8080:8080
fi

if [ -e .git ]; then
    primary_worktree=$(git worktree list | head -n1 | cut -f1 -d' ')
    if [ -f .git ]; then
        podman_args+=(-v "${primary_worktree}:${primary_worktree}:${git_mount_mode}")
    fi
    podman_args+=(-v "${PWD}"/.git:"${PWD}"/.git:"${git_mount_mode}")
    if [ "${git_mount_mode}" = "rw" ]; then
        podman_args+=(-v "${HOME}/.gitconfig:${HOME}/.gitconfig:ro")
        podman_args+=(-v "${HOME}/.ssh/id_ed25519.git-sign:${HOME}/.ssh/id_ed25519.git-sign:ro")
        podman_args+=(-v "${HOME}/.ssh/id_ed25519.git-sign.pub:${HOME}/.ssh/id_ed25519.git-sign.pub:ro")
        # Create a read-only backup of .git for recovery
        rm -rf "${primary_worktree}"/.git/bak
        cp --reflink=always -a "${primary_worktree}/.git" \
            "${primary_worktree}/.git-bak-tmp"
        mv "${primary_worktree}/.git-bak-tmp" "${primary_worktree}/.git/bak"
        podman_args+=(-v "${primary_worktree}/.git/bak:${primary_worktree}/.git/bak:ro")
    fi
    mount_target_symlink "${PWD}"
fi

for dir in "${add_dirs[@]}"; do
    podman_args+=(-v "${dir}:${dir}")
    mount_target_symlink "${dir}"
    if [ "${mode}" = "claude" ]; then
        tool_args+=(--add-dir "${dir}")
    fi
done

for repo in "${add_repos[@]}"; do
    if [[ "${repo}" == *:rw ]]; then
        repo_mode=rw
        repo=${repo%:rw}
    elif [[ "${repo}" == *:ro ]]; then
        repo_mode=ro
        repo=${repo%:ro}
    else
        repo_mode=ro
    fi
    repo_path=$(realpath "$(codeswitch ~/Code "${repo}")")
    podman_args+=(-v "${repo_path}:${repo_path}:${repo_mode}")
    mount_target_symlink "${repo_path}"
    if [ "${mode}" = "claude" ]; then
        tool_args+=(--add-dir "${repo_path}")
    fi
done

for vol in "${extra_volumes[@]}"; do
    podman_args+=(-v "${vol}")
done

if [ "${mount_gh}" = "true" ]; then
    GITHUB_TOKEN=$(secret-tool lookup github-cli-read-only token)
    export GITHUB_TOKEN
    podman_args+=(--env GITHUB_TOKEN)
fi

if [ "${mount_glab}" = "true" ]; then
    podman_args+=(-v "${HOME}/.config/glab-cli/config.yml:${HOME}/.config/glab-cli/config.yml:ro")
fi

if [ "${mount_oci_auth}" = "true" ]; then
    podman_args+=(-v "${HOME}/.docker/config.json:${HOME}/.docker/config.json:ro")
fi

if [ "${mount_imgs}" = "true" ]; then
    podman_args+=(-v "/srv/imgs:/run/host/srv/imgs:rw")
fi

# add tmux info if we're running in tmux
if [ -n "${TMUX_PANE:-}" ]; then
    podman_args+=(--label TMUX_PANE="${TMUX_PANE}")
    podman_args+=(--label TMUX_WINDOW="$(tmux display-message -p '#{window_id}')")
fi

# env vars
# shellcheck disable=SC1090
source ~/"Documents/Red Hat/claude-env.sh"

if [ "${mode}" = "claude" ]; then
    podman_args+=(
        --env CLAUDE_CODE_USE_VERTEX
        --env CLOUD_ML_REGION
        --env ANTHROPIC_VERTEX_PROJECT_ID
        --env DISABLE_AUTOUPDATER=1
    )
    HOST_SPAWN_ENV=CLAUDE_CODE_USE_VERTEX,CLOUD_ML_REGION,ANTHROPIC_VERTEX_PROJECT_ID,DISABLE_AUTOUPDATER
else
    podman_args+=(
        --env VERTEX_REGION
        --env GOOGLE_CLOUD_PROJECT
        --env OPENCODE_PERMISSION='{"external_directory":"allow"}'
        --env OPENCODE_EXPERIMENTAL_PLAN_MODE=true
    )
    HOST_SPAWN_ENV=VERTEX_REGION,GOOGLE_CLOUD_PROJECT,OPENCODE_PERMISSION
fi

if [ "${mount_gh}" = "true" ]; then
    HOST_SPAWN_ENV="${HOST_SPAWN_ENV},GITHUB_TOKEN"
fi

# cargo env vars - pass through all CARGO_* variables
while IFS='=' read -r var _; do
    if [[ "$var" == CARGO_* ]]; then
        podman_args+=(--env "$var")
        HOST_SPAWN_ENV="${HOST_SPAWN_ENV},${var}"
    fi
done < <(env)

# C/C++ compiler env vars
for var in CC CFLAGS CXXFLAGS; do
    if [ -n "${!var:-}" ]; then
        podman_args+=(--env "$var")
        HOST_SPAWN_ENV="${HOST_SPAWN_ENV},${var}"
    fi
done

export HOST_SPAWN_ENV

# claude doesn't like running as root with --dangerously-skip-permissions
# (there's IS_SANDBOX=1, but then you have to approve a bypass prompt)
if [ "${mode}" = "claude" ]; then
    podman_args+=(--userns=keep-id)
fi

# and the actual image and command
podman_args+=("${imageid}")
if [ "${run_bash}" = "true" ]; then
    exec podman "${podman_args[@]}" bash
elif [ "${mode}" = "claude" ]; then
    podman_args+=(
        "${HOME}"/Code/nodejs/bin/claude
        --dangerously-skip-permissions
    )
    exec podman "${podman_args[@]}" "${tool_args[@]}"
else
    exec podman "${podman_args[@]}" bash -c '
force_update="$1"; shift
bin="$HOME/.opencode/bin/opencode"
if [ -f "$bin" ]; then
    mtime=$(stat -c %Y "$bin" 2>/dev/null || echo 0)
    now=$(date +%s)
    if [ "$force_update" = "true" ] || [ $((now - mtime)) -gt 86400 ]; then
        "$bin" upgrade && touch "$bin"
    fi
fi
exec "$bin" "$@"' -- "${force_update}" "${tool_args[@]}"
fi
