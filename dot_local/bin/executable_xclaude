#!/bin/bash
set -euo pipefail
shopt -s inherit_errexit

# Run claude in an unprivileged container using the same container image in
# which we're running. The primary use case is a pet container image you've
# customized with various dev tools, and you want Claude to be able to use those
# tools as well in --dangerously-skip-permissions mode. Note this runs `podman`;
# in my case, `podman` is actually ~/.local/bin/podman and just proxies to the
# real host podman via `host-spawn`. That wrapper is available in my dotfiles
# repo as well, but one can probably just change the podman call at the bottom
# to `flatpak-spawn --host`

if [ ! -e "/run/.containerenv" ]; then
    echo "ERROR: Must be run from pet container" >&2
    exit 1
fi

# Parse our own arguments
add_dirs=()
add_repos=()
extra_volumes=()
claude_args=()
git_mount_mode=ro
run_bash=false
custom_image=""
mount_gh=false
usage() {
    cat <<EOF
Usage: xclaude [OPTIONS] [-- CLAUDE_ARGS...]

Run claude in an unprivileged container.

Options:
  -h            Show this help message
  --git-rw      Mount .git directory read-write (default: read-only)
  --bash        Run bash instead of claude
  --image IMG   Use a custom container image
  --gh          Mount GitHub credentials and set GITHUB_TOKEN
  --add-dir DIR Add a directory to the container
  --add-repo R  Add a repo (comma-separated) from ~/Code
  -v VOLUME     Add an extra volume mount
  --            Stop parsing options; remaining args passed to claude
EOF
}

while [ $# -gt 0 ]; do
    case "$1" in
        -h)
            usage
            exit 0
            ;;
        --)
            shift
            claude_args+=("$@")
            break
            ;;
        --git-rw)
            git_mount_mode=rw
            shift
            ;;
        --bash)
            run_bash=true
            shift
            ;;
        --image)
            if [ -z "${2:-}" ]; then
                echo "ERROR: --image requires an image argument" >&2
                exit 1
            fi
            custom_image="$2"
            shift 2
            ;;
        --gh)
            mount_gh=true
            shift
            ;;
        --add-dir)
            if [ -z "${2:-}" ]; then
                echo "ERROR: --add-dir requires a directory argument" >&2
                exit 1
            fi
            add_dirs+=("$(realpath "$2")")
            shift 2
            ;;
        --add-repo)
            if [ -z "${2:-}" ]; then
                echo "ERROR: --add-repo requires a repo name argument" >&2
                exit 1
            fi
            IFS=',' read -ra repos <<< "$2"
            add_repos+=("${repos[@]}")
            shift 2
            ;;
        -v)
            if [ -z "${2:-}" ]; then
                echo "ERROR: -v requires a volume argument" >&2
                exit 1
            fi
            extra_volumes+=("$2")
            shift 2
            ;;
        *)
            claude_args+=("$1")
            shift
            ;;
    esac
done

if [ ! -e .git ] && [ -z "${SAFE_PWD:-}" ]; then
    echo "ERROR: not in a git repo; remember we relabel \$PWD!" >&2
    exit 1
fi

# Check if there's a newer version of claude-code available
claude_manifest=~/Code/nodejs/lib/node_modules/\@anthropic-ai/claude-code/package.json
current_version=$(jq -r '.version' "${claude_manifest}")
latest_version=$(curl -s https://registry.npmjs.org/@anthropic-ai/claude-code/latest | jq -r '.version')
if [ -n "${latest_version}" ] && [ "${current_version}" != "${latest_version}" ]; then
    echo "Updating @anthropic-ai/claude-code from ${current_version} to ${latest_version}..."
    npm update --prefix ~/Code/nodejs -g @anthropic-ai/claude-code
fi

cd "$(realpath "${PWD}")"

if [ -n "${custom_image}" ]; then
    imageid="${custom_image}"
else
    imageid=$(source /run/.containerenv; echo "${imageid}")
fi

podman_args=(
    run --rm -ti
    --label xclaude=1
    --env PATH
    --env HOME="${HOME}"
    --tmpfs "${HOME}"
    -v /etc/localtime:/etc/localtime:ro
    -v "${HOME}/.cache"
    -v "${HOME}/.cargo:${HOME}/.cargo:z"
    -v "${HOME}/.rustup:${HOME}/.rustup:ro,z"
    -v "${HOME}"/Code/nodejs:"${HOME}"/Code/nodejs:O
    -v "${HOME}"/.config/gcloud:"${HOME}"/.config/gcloud:z
    -v "${HOME}"/.claude.json:"${HOME}"/.claude.json:z
    -v "${HOME}"/.claude:"${HOME}"/.claude:z
    -v "${PWD}":"${PWD}":z
    -w "${PWD}"
)

if [ -e .git ]; then
    if [ -f .git ]; then
        primary_worktree=$(git worktree list | head -n1 | cut -f1 -d' ')
        podman_args+=(-v "${primary_worktree}:${primary_worktree}:${git_mount_mode}")
    fi
    podman_args+=(-v "${PWD}"/.git:"${PWD}"/.git:"${git_mount_mode}")
    if [ "${git_mount_mode}" = "rw" ]; then
        podman_args+=(-v "${HOME}/.gitconfig:${HOME}/.gitconfig:ro,z")
        podman_args+=(-v "${HOME}/.ssh/id_ed25519.git-sign:${HOME}/.ssh/id_ed25519.git-sign:ro,z")
        podman_args+=(-v "${HOME}/.ssh/id_ed25519.git-sign.pub:${HOME}/.ssh/id_ed25519.git-sign.pub:ro,z")
        # Create a read-only backup of .git for recovery
        rm -rf .git/bak
        cp --reflink=always -a .git .git-bak-tmp
        mv .git-bak-tmp .git/bak
        podman_args+=(-v "${PWD}"/.git/bak:"${PWD}"/.git/bak:ro)
    fi
    # If there's a target/ that's a symlink, mount its target too.
    # See `mkcachedir` for the use case for this.
    if [ -L target ]; then
        target_real=$(realpath target)
        podman_args+=(-v "${target_real}:${target_real}:z")
    fi
fi

for dir in "${add_dirs[@]}"; do
    container_dir="/dirs/$(basename "${dir}")"
    podman_args+=(-v "${dir}:${container_dir}:z")
    claude_args+=(--add-dir "${container_dir}")
done

for repo in "${add_repos[@]}"; do
    repo_path=$(codeswitch ~/Code "${repo}")
    podman_args+=(-v "${repo_path}:${repo_path}:z")
    claude_args+=(--add-dir "${repo_path}")
done

for vol in "${extra_volumes[@]}"; do
    podman_args+=(-v "${vol}")
done

if [ "${mount_gh}" = "true" ]; then
    GITHUB_TOKEN=$(gh auth token)
    export GITHUB_TOKEN
    podman_args+=(--env GITHUB_TOKEN)
fi

# add tmux info if we're running in tmux
if [ -n "${TMUX_PANE:-}" ]; then
    podman_args+=(--label TMUX_PANE="${TMUX_PANE}")
    podman_args+=(--label TMUX_WINDOW="$(tmux display-message -p '#{window_id}')")
fi

# claude env vars
# shellcheck disable=SC1090
source ~/"Documents/Red Hat/claude-env.sh"
podman_args+=(
    --env CLAUDE_CODE_USE_VERTEX
    --env CLOUD_ML_REGION
    --env ANTHROPIC_VERTEX_PROJECT_ID
    --env DISABLE_AUTOUPDATER=1
)
HOST_SPAWN_ENV=CLAUDE_CODE_USE_VERTEX,CLOUD_ML_REGION,ANTHROPIC_VERTEX_PROJECT_ID,DISABLE_AUTOUPDATER
if [ "${mount_gh}" = "true" ]; then
    HOST_SPAWN_ENV="${HOST_SPAWN_ENV},GITHUB_TOKEN"
fi

# cargo env vars - pass through all CARGO_* variables
while IFS='=' read -r var _; do
    if [[ "$var" == CARGO_* ]]; then
        podman_args+=(--env "$var")
        HOST_SPAWN_ENV="${HOST_SPAWN_ENV},${var}"
    fi
done < <(env)

# C/C++ compiler env vars
for var in CC CFLAGS CXXFLAGS; do
    if [ -n "${!var:-}" ]; then
        podman_args+=(--env "$var")
        HOST_SPAWN_ENV="${HOST_SPAWN_ENV},${var}"
    fi
done

export HOST_SPAWN_ENV

# claude doesn't like running as root with --dangerously-skip-permissions
# (there's IS_SANDBOX=1, but then you have to approve a bypass prompt)
podman_args+=(--userns=keep-id)

# and the actual image and command
podman_args+=("${imageid}")
if [ "${run_bash}" = "true" ]; then
    exec podman "${podman_args[@]}" bash
else
    podman_args+=(
        "${HOME}"/Code/nodejs/bin/claude
        --dangerously-skip-permissions
    )
    exec podman "${podman_args[@]}" "${claude_args[@]}"
fi
