#!/bin/bash
set -euo pipefail
shopt -s inherit_errexit

# Run claude in an unprivileged container using the same container image in
# which we're running. The primary use case is a pet container image you've
# customized with various dev tools, and you want Claude to be able to use those
# tools as well in --dangerously-skip-permissions mode. Note this runs `podman`;
# in my case, `podman` is actually ~/.local/bin/podman and just proxies to the
# real host podman via `host-spawn`. That wrapper is available in my dotfiles
# repo as well, but one can probably just change the podman call at the bottom
# to `flatpak-spawn --host`

if [ ! -e "/run/.containerenv" ]; then
    echo "ERROR: Must be run from pet container" >&2
    exit 1
fi

# Parse our own arguments
add_dirs=()
extra_volumes=()
claude_args=()
git_mount_mode=ro
run_bash=false
custom_image=""
mount_gh=false
while [ $# -gt 0 ]; do
    case "$1" in
        --git-rw)
            git_mount_mode=rw
            shift
            ;;
        --bash)
            run_bash=true
            shift
            ;;
        --image)
            if [ -z "${2:-}" ]; then
                echo "ERROR: --image requires an image argument" >&2
                exit 1
            fi
            custom_image="$2"
            shift 2
            ;;
        --gh)
            mount_gh=true
            shift
            ;;
        --add-dir)
            if [ -z "${2:-}" ]; then
                echo "ERROR: --add-dir requires a directory argument" >&2
                exit 1
            fi
            add_dirs+=("$(realpath "$2")")
            shift 2
            ;;
        -v)
            if [ -z "${2:-}" ]; then
                echo "ERROR: -v requires a volume argument" >&2
                exit 1
            fi
            extra_volumes+=("$2")
            shift 2
            ;;
        *)
            claude_args+=("$1")
            shift
            ;;
    esac
done

if [ ! -e .git ] && [ -z "${SAFE_PWD:-}" ]; then
    echo "ERROR: not in a git repo; remember we relabel \$PWD!" >&2
    exit 1
fi

# Check if there's a newer version of claude-code available
claude_manifest=~/node_modules/\@anthropic-ai/claude-code/package.json
current_version=$(jq -r '.version' "${claude_manifest}")
latest_version=$(curl -s https://registry.npmjs.org/@anthropic-ai/claude-code/latest | jq -r '.version')
if [ -n "${latest_version}" ] && [ "${current_version}" != "${latest_version}" ]; then
    echo "Updating @anthropic-ai/claude-code from ${current_version} to ${latest_version}..."
    npm update @anthropic-ai/claude-code
fi

cd "$(realpath "${PWD}")"

if [ -n "${custom_image}" ]; then
    imageid="${custom_image}"
else
    imageid=$(source /run/.containerenv; echo "${imageid}")
fi

podman_args=(
    run --rm -ti
    --hostname claude
    --label xclaude=1
    --env PATH
    --env HOME="${HOME}"
    --tmpfs "${HOME}"
    -v /etc/localtime:/etc/localtime:ro
    -v "${HOME}/.cache"
    -v "${HOME}/.cargo:${HOME}/.cargo:z"
    -v "${HOME}/.rustup:${HOME}/.rustup:ro,z"
    -v "${HOME}"/node_modules:"${HOME}"/node_modules:O
    -v "${HOME}"/.config/gcloud:"${HOME}"/.config/gcloud:z
    -v "${HOME}"/.claude.json:"${HOME}"/.claude.json:z
    -v "${HOME}"/.claude:"${HOME}"/.claude:z
    -v "${PWD}":"${PWD}":z
    -w "${PWD}"
)

if [ -e .git ]; then
    if [ -f .git ]; then
        primary_worktree=$(git worktree list | head -n1 | cut -f1 -d' ')
        podman_args+=(-v "${primary_worktree}:${primary_worktree}:${git_mount_mode}")
    fi
    podman_args+=(-v "${PWD}"/.git:"${PWD}"/.git:"${git_mount_mode}")
    if [ "${git_mount_mode}" = "rw" ]; then
        podman_args+=(-v "${HOME}/.gitconfig:${HOME}/.gitconfig:ro,z")
        podman_args+=(-v "${HOME}/.ssh/id_ed25519.git-sign:${HOME}/.ssh/id_ed25519.git-sign:ro,z")
        podman_args+=(-v "${HOME}/.ssh/id_ed25519.git-sign.pub:${HOME}/.ssh/id_ed25519.git-sign.pub:ro,z")
        # Create a read-only backup of .git for recovery
        rm -rf .gitro
        cp --reflink=always -a .git .gitro
        podman_args+=(-v "${PWD}"/.gitro:"${PWD}"/.gitro:ro)
    fi
    # If there's a target/ that's a symlink, mount its target too.
    # See `mkcachedir` for the use case for this.
    if [ -L target ]; then
        target_real=$(realpath target)
        podman_args+=(-v "${target_real}:${target_real}:z")
    fi
fi

for dir in "${add_dirs[@]}"; do
    container_dir="/dirs/$(basename "${dir}")"
    podman_args+=(-v "${dir}:${container_dir}:z")
    claude_args+=(--add-dir "${container_dir}")
done

for vol in "${extra_volumes[@]}"; do
    podman_args+=(-v "${vol}")
done

if [ "${mount_gh}" = "true" ]; then
    GITHUB_TOKEN=$(gh auth token)
    export GITHUB_TOKEN
    podman_args+=(--env GITHUB_TOKEN)
fi

# add tmux info if we're running in tmux
if [ -n "${TMUX_PANE:-}" ]; then
    podman_args+=(--label TMUX_PANE="${TMUX_PANE}")
    podman_args+=(--label TMUX_WINDOW="$(tmux display-message -p '#{window_id}')")
fi

# claude env vars
# shellcheck disable=SC1090
source ~/Temp/claude-env-work.sh
podman_args+=(
    --env CLAUDE_CODE_USE_VERTEX
    --env CLOUD_ML_REGION
    --env ANTHROPIC_VERTEX_PROJECT_ID
    --env DISABLE_AUTOUPDATER=1
)
HOST_SPAWN_ENV=CLAUDE_CODE_USE_VERTEX,CLOUD_ML_REGION,ANTHROPIC_VERTEX_PROJECT_ID,DISABLE_AUTOUPDATER
if [ "${mount_gh}" = "true" ]; then
    HOST_SPAWN_ENV="${HOST_SPAWN_ENV},GITHUB_TOKEN"
fi
export HOST_SPAWN_ENV

# claude doesn't like running as root with --dangerously-skip-permissions
# (there's IS_SANDBOX=1, but then you have to approve a bypass prompt)
podman_args+=(--userns=keep-id)

# and the actual image and command
podman_args+=("${imageid}")
if [ "${run_bash}" = "true" ]; then
    exec podman "${podman_args[@]}" bash
else
    podman_args+=(
        npm exec claude
        --
        --dangerously-skip-permissions
    )
    exec podman "${podman_args[@]}" "${claude_args[@]}"
fi
